# -*- ispell-local-dictionary: "brasileiro"; -*-
#+TITLE: Um pouco sobre GDB
#+AUTHOR: Darlan Cavalcante Moreira
#+DATE: Julho, 2022

#+OPTIONS: toc:1 num:nil timestamp:nil tags:nil
#+COLUMNS: %40ITEM %CUSTOM_ID %reveal_data_state %reveal_extra_attr

:MY-REVEAL-EXPORT-OPTIONS:
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_THEME: serif

#+REVEAL_REVEAL_JS_VERSION: 4
#+REVEAL_MIN_SCALE:1
#+REVEAL_INIT_OPTIONS: margin: 0.0, width: 1777, height: 1000,
#+REVEAL_INIT_OPTIONS: slideNumber: "c/t", transition: 'slide', transitionSpeed: "fast", history: false, hash: true, respondToHashChanges: true
#+REVEAL_PLUGINS: (highlight notes zoom search)
#+REVEAL_EXTERNAL_PLUGINS: (plugin1 . "ex/plugin1.js")
#+REVEAL_TITLE_SLIDE: <h1 class="title">%t</h1><h2>%s</h2></br></br></br><h3 class="author">%a</h3><h4 class="date">%d</h4>
#+HTML_HEAD_EXTRA: <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/a11y-dark.min.css">
#+HTML_HEAD_EXTRA: <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
#+REVEAL_EXTRA_CSS: css/code_blocks.css
#+REVEAL_EXTRA_CSS: css/kbd.css
#+REVEAL_EXTRA_CSS: css/beamer_like_blocks.css
#+REVEAL_TITLE_SLIDE_STATE: presentation-title-slide
#+REVEAL_TOC_SLIDE_BACKGROUND: ./images/table-of-contents.jpg
#+REVEAL_TOC_SLIDE_BACKGROUND_OPACITY: 0.1
#+MACRO: frag (eval (concat "@@html:<span class=\"fragment\">@@" $1 "@@html:</span>@@"))
#+MACRO: kbd (eval (concat "@@html:<kbd>@@" $1 "@@html:</kbd>@@"))


#+REVEAL_EXTRA_CSS: css/presentation.css
#+REVEAL_EXTRA_CSS: css/my_remark_main.css


:END:


* TODO Criar a class "dica" para um slide                                   :noexport:

Use
: :reveal_extra_attr: class="dica"
para atribuir a classe a um slide


* Bla bla                                                                  :noexport:
:PROPERTIES:
:REVEAL_DATA_STATE: session-separation-slide
:END:
REVEAL_SPEED: fast
REVEAL_MARGIN: 0.05
REVEAL_INIT_OPTIONS: reveal_width:1188 reveal_height:840
# A4 dimensions: 210 297 -> Vou usar 4 x esses valores
REVEAL_INIT_OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:nil
REVEAL_INIT_OPTIONS: reveal_slide_number:c/t

* Navegando nessa apresenta√ß√£o
** B√°sico do [[https://revealjs.com/][reveal.js]]
:PROPERTIES:
:CUSTOM_ID: basico-do-revealjs
:END:
#+ATTR_REVEAL: :frag (t)
- No reveal.js os slides s√£o organizados em um grid 2D
  - Temos slides verticais e horizontais ‚Üí tente {{{kbd(Esc)}}}
- Use {{{kbd(Space)}}} para passar para o pr√≥ximo slide
- Use {{{kbd(Shift)}}} + {{{kbd(Space)}}} para voltar um slide
- √â poss√≠vel fazer uma busca em toda a apresenta√ß√£o com {{{kbd(Ctrl)}}} + {{{kbd(Shift)}}} + {{{kbd(f)}}}
* Vamos ao b√°sico
:PROPERTIES:
:CUSTOM_ID: basico-do-gdb
:REVEAL_DATA_STATE: session-separation-slide
:END:
** Inicializando o GDB
:PROPERTIES:
:CUSTOM_ID:       inicializando-gdb
:REVEAL_DATA_STATE:
:END:

- Para executar o gdb basta usar o comando abaixo no terminal
  #+begin_src bash
  gdb <execut√°vel>
  #+end_src
#+ATTR_REVEAL: :frag t
- O terminal muda para o prompt do gdb, onde diversos comandos est√£o dispon√≠veis

  [[./images/gdb-screen.png]]

** TUI
:PROPERTIES:
:CUSTOM_ID: tui
:END:

  #+ATTR_REVEAL: :frag (none t t t) :frag_idx (0 1 1 1)
- O GDB tamb√©m possui uma interface de usu√°rio em modo texto
- Use {{{kbd(Ctrl)}}}+{{{kbd(x)}}} {{{kbd(A)}}} para alternar entre a interface TUI e a interface normal
- Use {{{kbd(Ctrl)}}}+{{{kbd(x)}}} {{{kbd(2)}}} para dividir a tela
- Use {{{kbd(Ctrl)}}}+{{{kbd(x)}}} {{{kbd(1)}}} para voltar para uma √∫nica tela


#+ATTR_HTML: :class r-stretch
[[./images/gdb_tui.png]]

** Front-ends para GDB
:PROPERTIES:
:CUSTOM_ID: other-frontends
:END:
#+ATTR_REVEAL: :frag (none t) :frag_idx (0 1)
- H√° v√°rios front-ends para o GDB
  - [[https://github.com/cs01/gdbgui/][gdbgui]]
  - [[https://github.com/epasveer/seer][seer]]
  - [[https://github.com/rohanrhu/gdb-frontend][gdb-frontend]]
  - etc.
- Provavelmente sua IDE ou editor de texto (no Linux) usa o GDB
  - [[https://www.jetbrains.com/clion/][CLion]]
  - [[https://www.kdevelop.org/][KDevelop]]
  - [[https://code.visualstudio.com/][VSCode]]
  - [[https://www.gnu.org/software/emacs/][Emacs]]

** Comandos principais do GDB
:PROPERTIES:
:CUSTOM_ID: comandos-principais
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

- Alguns dos comandos principais do gdb s√£o

# # box moody
# #+ATTR_REVEAL: :frag (t)
# - Muitos outros comandos est√£o dispon√≠veis
#    # box happy
# - Voc√™ n√£o precisa digitar o comando completo
#     #+ATTR_REVEAL: :frag t
#   - Uma ou duas letras s√£o suficientes
#   - =b= para break, =c= para continue, etc


#+begin_src bash
file                                 # Seta o arquivo a ser debugado (caso j√° n√£o tenha sido passado)
set args <command_line_parameters>   # Seta os par√¢metros de linha de comando do programa
start                                # Inicia o programa a ser debugado parando na main
run, r                               # Roda o programa a ser debugado
backtrace, bt                        # Imprime o backtrace
frame, f                             # Seleciona ou imprime o frame stack
next, n                              # Avan√ßa uma linha no arquivo atual
step, s                              # Avan√ßa at√© a pr√≥xima linha de c√≥digo
until                                # Avan√ßa at√© a linha especificada
finish, fin                          # Executa o programa at√© o frame atual retornar (acabar a fun√ß√£o atual)
up, u                                # Seleciona e imprime o stack frame que chamou o atual
down, d                              # Seleciona e imprime o stack frame chamado pelo atual
break, b                             # Seta um breakpoint
rbreak, rb                           # Seta um breakpoint usando express√£o regular
ignore                               # Ignore um breakpoint um certo n√∫mero de vezes
continue, c                          # Continua execu√ß√£o do programa
info <break/threads/locals/args/etc> # Mostra informa√ß√µes do programa sendo debugado
help, h                              # Ajuda sobre os comandos
#+end_src


** Dica
:PROPERTIES:
:CUSTOM_ID: comandos-gdb-dica
:REVEAL_DATA_STATE: dica-slide
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

\\

Voc√™ n√£o precisa digitar o comando completo

Uma ou duas letras s√£o suficientes

=b= para break, =c= para continue, etc

** Criando breakpoints
:PROPERTIES:
:CUSTOM_ID: criando-breakpoints
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :frag (t)
- √â poss√≠vel adicionar breakpoints com

  #+begin_src bash
  b line_number                # adiciona breakpoint na linha especificada no arquivo atual
  b function_name              # adiciona breakpoint no in√≠cio da fun√ß√£o especificada
  b filename.cpp:line_number   # Adiciona breakpoint especificando a linha e o arquivo
  #+end_src

- Para templates o nome da fun√ß√£o deve incluir o tipo do template
- No caso da fun√ß√£o abaixo
  #+begin_src c++
  template <typename T>
  inline T doubleInput(const T& x) {
      return 2 * x;
  }
  #+end_src
  √© necess√°rio =b doubleInput<int>=, ou =b doubleInput<double>=
  - Note que ele vai parar apenas na inst√¢ncia espec√≠fica do template

- Caso use =b filename.cpp:line_number= em um template o gdb cria um breakpoint com
  m√∫ltiplas localiza√ß√µes (uma para cada inst√¢ncia do template)

** Criando breakpoints
:PROPERTIES:
:CUSTOM_ID: criando-breakpoints2
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :frag (none t t) :frag_idx (0 1 2)
- Outra op√ß√£o √© usar o comando =rbreak= para criar um breakpoint passando uma express√£o regular
  - Especialmente √∫til no caso de templates
- Com =rbreak doubleInput*= o gdb cria um breakpoint em todas as inst√¢ncias do template

  #+begin_src c++
  template <typename T>
  inline T doubleInput(const T& x) {
      return 2 * x;
  }
  #+end_src

- Outra op√ß√£o interessante √© =rbreak filename.cpp:.*= para adicionar um breakpoint em
  todas as fun√ß√µes de um arquivo

* Configurando o gdb
:PROPERTIES:
:CUSTOM_ID: configuracoes-interessantes
:REVEAL_DATA_STATE: session-separation-slide
:END:
** Evitando ver arquivos desinteressantes
:PROPERTIES:
:CUSTOM_ID: skip-files
:END:

#+ATTR_REVEAL: :frag (t)
- O comando =step= executa a pr√≥xima instru√ß√£o
  - entra em outras fun√ß√µes
- Normalmente s√≥ estamos interessados no c√≥digo do nosso programa
- Podemos pedir para o gdb pular arquivos desinteressantes
  - Arquivos no namespace std, ou outro de uma biblioteca externa
- Para isso usamos o comando =skip=
  #+begin_src text
  skip file
  skip function
  #+end_src
- *Dica*: podemos todas as fun√ß√µes em um namespace com
  #+begin_src bash
  skip -rfu ^std::
  #+end_src

** .gdbinit (global)
:PROPERTIES:
:CUSTOM_ID: gdbinit-global
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :frag (t t) :frag_idx (1 2)
- √â poss√≠vel configurar o gdb usando um arquivo =.gdbinit= na sua home
- Configura√ß√£o m√≠nima √∫til

  #+begin_src text
  set history save on
  set print pretty on
  set pagination off
  set confirm off

  skip -rfu ^std::
  skip ...                                                    # Coloque outros que costuma ignorar

  set auto-load local-gdbinit on                              # Permite carregar arquivos .gdbinit locais
  add-auto-load-safe-path /some_path/with/local_gdbinit_file/ # Uma pasta contendo um arquivo .gdbinit local
  #+end_src


** Dica
:PROPERTIES:
:CUSTOM_ID: gdb-global-dica
:REVEAL_DATA_STATE: dica-slide
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

\\

=.gdbinit= na sua home tamb√©m tem efeito quando o gdb √© usado com algum front-end

** .gdbinit (local)
:PROPERTIES:
:CUSTOM_ID: gdbinit-local
:END:

#+ATTR_REVEAL: :frag (t)
- Tamb√©m √© poss√≠vel ter um arquivo =.gdbinit= por projeto
  #+ATTR_REVEAL: :frag t
  - Na verdade por pasta
- Ele √© carregado al√©m do =.gdbinit= global
- *Exemplo*: Coloque o conte√∫do abaixo em um arquivo =.gdbinit= na mesma pasta contendo
  seu programa

  #+begin_src gdb-script
  file seu_executavel
  start
  b main.cpp:11
  run
  #+end_src

- Devido a quest√µes de seguran√ßa √© necess√°rio adicionar a linha abaixo no arquivo =.gdbinit= na sua home

  #+begin_src gdb-script
  set auto-load local-gdbinit on
  add-auto-load-safe-path /path_da_pasta_onde_esta_o_outro_gdb_init/
  #+end_src

* Truques √∫teis
:PROPERTIES:
:CUSTOM_ID: truques-uteis
:REVEAL_DATA_STATE: session-separation-slide
:END:
** Breakpoint Commands
:PROPERTIES:
:CUSTOM_ID: breakpoint-commands
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :frag (t)
- S√£o comandos executados ao atingir um breakpoint espec√≠fico
- Qualquer comando do gdb pode ser executado dessa forma
  - At√© mesmo =run= para recome√ßar a execu√ß√£o do programa

- Para adicionar comandos use
    #+begin_src gdb-script
    commands <n√∫mero do breakpoint>
    > algum comando
    > outro comando
    > end
    #+end_src

** Dica
:PROPERTIES:
:REVEAL_EXTRA_ATTR: data-auto-animate
:CUSTOM_ID: breakpoint-commands-dica
:REVEAL_DATA_STATE: dica-slide
:END:

\\

Comandos de breakpoint e um arquivo =.gdbinit= local podem automatizar toda uma sess√£o de
debug

** Exemplo
:PROPERTIES:
:CUSTOM_ID: breakpoint-commands-example
:reveal_extra_attr: data-auto-animate
:END:

- O programa abaixo cria um array de 20 elementos e preenche o mesmo com valores aleat√≥rios
  - Na maior parte do tempo ele funciona, mas as vezes ele da crash


#+begin_src c++
#include <ctime>
#include <stdexcept>
#include <iostream>

double computeInverse(double value) {
    if (value == 0) throw std::runtime_error("Value cannot be zero");
    return 1.0 / value;
}

int main() {
    srand(time(NULL));
    constexpr unsigned int arraySize = 20;
    int array[arraySize];

    for(unsigned int i = 0; i < arraySize; i++) {
        auto denominator = rand() % 200;
        array[i]         = computeInverse(denominator);
    }
    std::cout << "Fim" << std::endl;
    return 0;
}
#+end_src

** Exemplo
:PROPERTIES:
:CUSTOM_ID: breakpoint-commands-example2
:reveal_extra_attr: data-auto-animate
:END:

# :reveal_extra_attr: data-transition="fade"

#+ATTR_REVEAL: :frag (t)
- Para encontrar o bug, primeiro adicionamos um breakpoint na √∫ltima instru√ß√£o do programa

  #+begin_src gdb-script
  start
  b _exit
  #+end_src

- Verificamos o n√∫mero do breakpoint com =i b=
- Supondo que o n√∫mero do breakpoint em =_exit= √© 2, use =gdb commands 2=
  - Agora escreva =run=, pressione {{{kbd(Enter)}}}, e escreva =end= para finalizar
  - Rode o programa com o comando =run=
  - Caso o programa termine sem atingir o bug ele chegar√° no breakpoint em
    =_exit= e ser√° automaticamente reinicializado pelo comando =run= at√© que
    eventualmente o bug ocorra

** Exibindo uma express√£o sempre que parar
:PROPERTIES:
:CUSTOM_ID: display-variables
:END:

#+ATTR_REVEAL: :frag (t)
- Para imprimir uma vari√°vel ou express√£o sempre que parar em um breakpoint use
  #+begin_src gdb-script
  display expr
  #+end_src
  onde =expr= pode ser alguma express√£o ou vari√°vel
- Para ver o que foi configurado use
  #+begin_src gdb-script
  info display
  #+end_src
- Para deletar uma express√£o ou desabilit√°-la use
  #+begin_src gdb-script
  delete display <NUM>
  disable/enable display <NUM>
  #+end_src

** Inserindo printfs sem recompilar
:PROPERTIES:
:CUSTOM_ID: dynamic-printfs
:END:

#+ATTR_REVEAL: :frag (t)
- Outro recurso interessante √© adicionar printfs sem recompilar
  #+begin_src bash
  dprintf location, formatting-string, expr1, expr2, ...
  #+end_src
- Nesse caso o valor ser√° impresso sempre que passar pela linha indicada

** Vari√°veis de Conveni√™ncia
:PROPERTIES:
:CUSTOM_ID: convenience-variables
:reveal_extra_attr: data-auto-animate
:END:

#+ATTR_REVEAL: :frag (t)
- GDB permite salvar "vari√°veis de conveni√™ncia"
  #+ATTR_REVEAL: :frag (t)
  - Essas vari√°veis existem apenas no GDB e n√£o afetam o programa em execu√ß√£o
  - Voc√™ pode usar para guardar qualquer coisa (valores, ponteiros, express√µes, etc)
- Vari√°veis de conveni√™ncia s√£o prefixadas com =$=
  - Qualquer nome precedido de =$= √© v√°lido (exceto se for igual a algum registrador)
  # - Tamb√©m h√° "refer√™ncias de hist√≥rico", que s√£o n√∫meros precedidos de =$=
- Para criar uma vari√°vel de conveni√™ncia usamos =set=
  #+begin_src text
  set $foo = *object_ptr
  #+end_src
- podemos ver seu valor como qualquer outra vari√°vel
  #+begin_src text
  print $foo
  #+end_src
- Para mostrar todas as vari√°veis de conveni√™ncia use
  #+begin_src text
  show convenience
  #+end_src

# ![:box moody, Dica]

** Dica
:PROPERTIES:
:CUSTOM_ID: convenience-variables-hint
:REVEAL_EXTRA_ATTR: data-auto-animate
:REVEAL_DATA_STATE: dica-slide
:END:

\\

Salve o ponteiro de um objeto em uma vari√°vel de conveni√™ncia. \\
Assim poder√° acess√°-lo de qualquer outro local. \\
(desde que o objeto ainda exista)

** Arrays Artificiais
:PROPERTIES:
:CUSTOM_ID: view-arrays
:reveal_extra_attr: data-auto-animate data-auto-animate-restart
:END:

#+ATTR_REVEAL: :frag (t)
- √â poss√≠vel imprimir o conte√∫do de um array com

  #+begin_src gdb-script
  p *array@len
  #+end_src

- Funciona at√© mesmo para m√∫ltiplas dimens√µes (cuidado com a ordem)

  #+begin_src gdb-script
  p *array2d@num_cols@num_rows
  #+end_src
** Arrays Artificiais
:PROPERTIES:
:CUSTOM_ID: view-arrays-exemplo
:reveal_extra_attr: data-auto-animate
:END:


#+ATTR_REVEAL: :frag (t)
- As vari√°veis =a= e =m= podem ser impressas diretamente
- Mas =aPtr= e =mPtr= s√£o apenas ponteiros
  - Podemos ver todos os elementos usando =@= e o tamanho

#+html: <div class="columns">
#+html: <div class="column w-50">
#+CAPTION: Exemplo
#+begin_src c++
int main() {
    int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int* aPtr = a;

    int m[4][3] = {{1, 2, 3}, //
                   {4, 5, 6}, //
                   {7, 8, 9}, //
                   {10, 11, 12}};
    int* mPtr = &m[0][0];

    return 0;
}
#+end_src

#+html: </div>
#+html: <div class="column w-50">
#+ATTR_REVEAL: :frag t
[[./images/print_arrays.png]]
#+html: </div>
#+html: </div>

** Ver um campo em um array de estruturas
:PROPERTIES:
:CUSTOM_ID: view-struct-arrays
:END:

#+ATTR_REVEAL: :frag (t)
- Considere um array de estruturas onde queremos ver apenas um campo
- Um truque interessante √© usar uma vari√°vel de conveni√™ncia como contador
  #+begin_src gdb-script
  set $i = 0
  p mystruct_array[$i++]->some_field
  #+end_src
  #+ATTR_REVEAL: :frag t
  - {{{kbd(Enter)}}} no gdb repete o √∫ltimo comando
  - Basta pressionar {{{kbd(Enter)}}} repetidamente para ver os pr√≥ximos elementos

- Tamb√©m √© poss√≠vel usar a vari√°vel de conveni√™ncia dentro de um loop
  #+begin_src gdb-script
  set $i = 0
  while ($i < array_length)
      p mystruct_array[$i++]->some_field
  end
  #+end_src

** Usando com tipos do Armadillo                                          :noexport:
:PROPERTIES:
:CUSTOM_ID: vendo-tipos-do-armadillo
:END:


- Os tipos do armadillo possuem um ponteiro chamado =mem= que aponta para a
  regi√£o de mem√≥ria onde os elementos s√£o armazenados
- Vara visualizar um vetor use o c√≥digo abaixo

#+begin_src gdb-script
p *myvec.mem@size
#+end_src

- Para matrizes use

#+begin_src gdb-script
p *mymat.mem@n_rows@n_cols
#+end_src

* Tipos de breakpoints
:PROPERTIES:
:CUSTOM_ID: tipos-de-breakpoint
:REVEAL_DATA_STATE: session-separation-slide
:END:

** Os 3 tipos de breakpoint
:PROPERTIES:
:CUSTOM_ID: tres-tipos-de-breakpoint
:END:

- H√° tr√™s tipos de "breakpoint" no gdb:
  #+ATTR_REVEAL: :frag (t)
  - breakpoints :: Seu programa para quando um certo ponto √© atingido
  - watchpoints (aka, data breakpoint) :: Seu programa para quando o valor de uma
    express√£o muda
  - catchpoints :: Seu programa para quando um evento especial ocorre
    - disparo de uma exce√ß√£o
    - quando uma biblioteca √© carregada
    - etc


#+ATTR_HTML: :class fragment box moody
Breakpoints podem ter uma condi√ß√£o de parada


** Catchpoints
:PROPERTIES:
:CUSTOM_ID: break-in-exceptions
:END:

#+ATTR_REVEAL: :frag (t)
- Para parar seu programa quando uma exce√ß√£o √© disparada use
  #+begin_src gdb-script
  catch throw
  run
  #+end_src

- Nota: vai para em qualquer exce√ß√£o disparada
- Dica: use =catch throw= como um comando que √© rodado quando algum outro
  breakpoint for atingido para capturar apenas exce√ß√µes disparadas depois dele


\\

#+ATTR_HTML: :class fragment box moody
Veja outros eventos de catch na documenta√ß√£o do gdb

** Watchpoints
:PROPERTIES:
:CUSTOM_ID: watchpoints
:END:

#+ATTR_REVEAL: :frag (t t t) :frag_idx (1 2 3)
- Exemplo de uso: pare quando uma vari√°vel =x= for alterada
  #+begin_src gdb-script
  watch x
  #+end_src

- Tamb√©m √© poss√≠vel parar sempre que uma vari√°vel for lida com

  #+begin_src gdb-script
  rwatch x
  #+end_src

- Se quiser parar em ambos os casos use

  #+begin_src gdb-script
  awatch x
  #+end_src

\\

# ![:box happy, Dica]
#+ATTR_HTML: :class moody box fragment :data-fragment-index 4
Veja mais sobre breakpoints com =help breakpoints= no gdb


# {{{happybox(Veja mais sobre breakpoints com =help breakpoints= no gdb)}}}

  # ![:box moody, Nota](
# - Se passar a op√ß√£o =-l= o gdb vai observar a regi√£o de mem√≥ria resultante da express√£o

* Python
:PROPERTIES:
:CUSTOM_ID: python
:REVEAL_DATA_STATE: session-separation-slide
:END:
** gdb + Python = üíò
:PROPERTIES:
:CUSTOM_ID: gdb-com-python
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :frag (t)
- GDB possui um interpretador python integrado
- Para rodar um comando em python use =python comando=
- Ou inicialize um interpretador python com =python-interactive= ou apenas =pi=
- No python integrado a um m√≥dulo =gdb= que pode ser usado para interagir com o gdb
- Exemplo:
  # - "6 por meia d√∫zia": =python gdb.execute("some gdb command")=
  - Acessando uma vari√°vel no python:
    #+begin_src gdb-script
    python python_var = gdb.parse_and_eval("some_variable")
    #+end_src
- Use =python help('gdb')= para ver documenta√ß√£o do m√≥dulo =gdb=

- Exemplos (rode esses comandos no terminal do gdb)

  #+begin_src gdb-script
  python bp = gdb.Breakpoint('main.cpp:13')
  python bp.enable=False
  python bps = gdb.breakpoints()
  python var_i = gdb.parse_and_eval('i')
  #+end_src

** Quais os usos √∫teis dessa integra√ß√£o?
:PROPERTIES:
:CUSTOM_ID: gdb-com-python-question
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_HTML: :width 55%
[[./images/question.jpg]]


** Pretty Printers
:PROPERTIES:
:CUSTOM_ID: pretty-printers
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

# - Possivelmente a aplica√ß√£o mais interessante de python com o gdb

#+ATTR_REVEAL: :frag (t)
- Podemos criar e registrar pretty printers para nossos tipos de interesse no C++
- Ensinamos ao gdb como representar um tipo C++ como string
- Suponha que voc√™ tenha um tipo chamado =mysctruct= contendo um campo =member=
- Podemos criar e registrar um pretty-printer para =mystruct= como abaixo

  #+begin_src python
  class MyPrinter(object):       # Classe que sabe converter nosso tipo em uma representa√ß√£o como string
      def __init__(self, val):   # 'val' √© a representa√ß√£o no nosso objeto C++ no Python
          self.val = val
      def to_string(self):
          return (self.val['member'])

  import gdb.printing
  pp = gdb.printing.RegexpCollectionPrettyPrinter("my_library")  # Vamos usar para registrar nosso PP
  pp.add_printer("mystruct", "^mystruct$", MyPrinter)            # Registra nosso pretty-printer
  #+end_src

- Basta carregar o arquivo Python com o c√≥digo acima no gdb com =source filename.py=




#+ATTR_HTML: :class fragment moody box
N√£o esque√ßa de colocar =set print pretty on= no seu arquivo =.gdbinit= global

** Pretty Printers
:PROPERTIES:
:CUSTOM_ID: pretty-printers2
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :frag (t)
- O GDB j√° vem com pretty printers para os tipos da STL
- Ao imprimir um objeto do tipo =std::vector<myscruct>= vemos o efeito do pretty-printer para =std::vector=
  e para o tipo =mystruct=
- Exemplo: Visualizar uma matriz 6x3 de n√∫meros complexos (usando a biblioteca [[http://arma.sourceforge.net/][armadillo]])

  #+html: <div class="columns">
  #+ATTR_REVEAL: :frag t
  [[./images/m2_without_pretty_printing.png]]

  #+ATTR_REVEAL: :frag t
  [[./images/m2_with_pretty_printint.png]]
  #+html: </div>

** XMethods
:PROPERTIES:
:CUSTOM_ID: xmethods
:END:

#+ATTR_REVEAL: :frag (t)
- Xmethods s√£o m√©todos *adicionais* ou *substitutos* para m√©todos de uma classe em C++
  #+ATTR_REVEAL: :frag (t)
  - √ötil para casos quando os m√©todos definidos no C++ n√£o estejam dispon√≠veis
    (inline, optimized-out, etc)
  - Podem ser usados mesmo quando debugando a partir de um core file
- Para implementar um xmethod √© necess√°rio criar um =matcher= e um =worker=
  - Mais de um =worker= pode ser implementado para um mesmo xmethod, cada um
    correspondendo a um overload diferente

\\

#+ATTR_HTML: :class moody box fragment
Veja mais na documenta√ß√£o do gdb

** Python Interativo
:PROPERTIES:
:CUSTOM_ID: python-interativo
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :frag (t)
- O comando =pi= (ou =python-interactive=) roda o python de maneira iterativa
  - Especialmente √∫til para testes e para explorar a API
- Permite explorar o estado de um programa usando Python
- *Exemplo*: Gerar pontos uniformemente em um c√≠rculo
  #+begin_src c++
  std::vector<std::complex<double>> calcRandomPointsInsideCircle(unsigned int numPoints, double maxRadius) {
      std::default_random_engine generator;
      std::uniform_real_distribution<double> radiusDistribution(0.0, maxRadius);
      std::uniform_real_distribution<double> angleDistribution(0.0, 2 * M_PI);

      std::vector<std::complex<double>> points;
      points.reserve(numPoints);

      std::generate_n(std::back_inserter(points), numPoints, [&]() -> std::complex<double> {
          auto radius = radiusDistribution(generator);
          auto angle  = angleDistribution(generator);
          return radius * std::exp(std::complex<double>(0, -angle));
      });

      return points;
  }
  #+end_src

#+ATTR_HTML: :class fragment moody box
Como checar se os pontos gerados s√£o uniformes durante o plot?



# - Adicione a linha abaixo no seu =.gdbinit= ap√≥s clonar o reposit√≥rio
#   =gdb_armadillo_helpers= para ter a fun√ß√£o =get_arrat= dispon√≠vel no python do gdb

#   #+begin_src gdb-script
#   source /path_onde_clonou/gdb_armadillo_helpers/gdb_helpers/gdb_armadillo_to_numpy.py
#   #+end_src

# - Agora rode o python iterativo com o comando =pi=
# - Supondo que voc√™ possui um =arma::cx_mat= de nome =m= voc√™ pode criar um numpy
#   array a partir dele com

#   #+begin_src python
#   >>> m_numpy = get_array(gdb.parse_and_eval('m'))
#   #+end_src


** Python Interativo
:PROPERTIES:
:CUSTOM_ID: python-interativo2
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

\\

Podemos visualizar os pontos gerados durante o debug ...

\\

#+ATTR_REVEAL: :frag t
usando matplotlib



** Python Interativo
:PROPERTIES:
:CUSTOM_ID: python-interativo3
:REVEAL_EXTRA_ATTR: data-auto-animate
:END:

#+ATTR_REVEAL: :frag (none t) :frag_idx (0 1)
- Para isso precisamos converter o vetor do =std::vector<std::complex<double>>= para um
  array do numpy
- Basta carregar o c√≥digo abaixo no gdb para poder usar durante o python interativo
  #+begin_src python
  def _cast_to_complex(gdb_value):
      double_t = gdb.lookup_type('double')
      # We need to cast gdb_value into an array of two doubles. Then we can
      # access the real and imaginary parts as the first and second elements
      real_and_imag_parts = gdb_value.cast(double_t.array(1))
      return complex(real_and_imag_parts[0], real_and_imag_parts[1])

  def get_array_from(v):
      start_mem = v["_M_impl"]["_M_start"]
      finish_mem = v["_M_impl"]["_M_finish"]
      n_elem = finish_mem - start_mem
      return np.array([_cast_to_complex(start_mem[i]) for i in range(n_elem)])
  #+end_src


** Ambiente virtual para o Python do gdb
:PROPERTIES:
:CUSTOM_ID: ambiente-virtual
:REVEAL_DATA_STATE:
:END:
# https://interrupt.memfault.com/blog/using-pypi-packages-with-GDB

#+ATTR_REVEAL: :frag (t t t t) :frag_idx (1 2 3 4)
- O gdb usa o python do sistema
- Podemos querer usar alguma biblioteca Python dentro do gdb
- Inicializar o gdb a partir de um ambiente virtual n√£o muda esse fato
- Solu√ß√£o:
  #+ATTR_REVEAL: :frag (strike t t) :frag_idx (5 5 6)
  - Instalar a biblioteca usando =sudo pip install=
  - Adicionar as pastas necess√°rias do path
  - Rode o comando abaixo no ambiente virtual

    #+begin_src bash
    python -c "import sys; print(sys.path)
    #+end_src
    e adicione as pastas no path do Python do gdb via =.gdbinit=

** Exemplo: Computar posi√ß√µes dos elementos de uma URA                    :noexport:
:PROPERTIES:
:CUSTOM_ID: exemplo1
:END:

  - Crie um arquivo =.gdbinit= na pasta contento o execut√°vel (chamado de =tests=)


#+begin_src gdb-script
  file tests
  set args "[Antenna]"
  start
  # Linha 311 √© logo ap√≥s a vari√°vel 'positions' ser setada
  b test_URA.cpp:311
  commands 2
    source plot_positions.py
  end
  run
#+end_src


  - Na mesma pasta crie o arquivo =plot_positions.py= com o conte√∫do abaixo


#+begin_src python
  from matplotlib import pyplot as plt
  p = get_array(gdb.parse_and_eval("positions")) # positions √© a vari√°vel no C++
  plt.plot(p[1], p[2], "*")
  for i in range(p.shape[1]):
      plt.text(p[1,i], p[2,i], i)
  plt.show()
#+end_src

** Exemplo √∫til: Computar posi√ß√µes dos elementos de uma URA               :noexport:
:PROPERTIES:
:CUSTOM_ID: exemplo2
:END:
- Agora basta rodar =gdb= e o programa vai parar na linha 311 e plotar as
  posi√ß√µes dos elementos de antenna


[[gdb_matplotlib.png]]

** IPython Interativo                                                     :noexport:
:PROPERTIES:
:CUSTOM_ID: ipython-interativo
:END:
- O python interativo do gdb funciona bem, mas n√£o chega perto de um IPython
- Iniciar o IPython a partir do gdb n√£o funciona (tab completion n√£o funciona
  al√©m de outros problemas
- **Workaround:** Inicializar um kernel embeded e conectar a partir de outro terminal
  1. Inicialize o python interativo com =pi=
  2. No python interativo rode o comando
     #+begin_src python
     import IPython; IPython.embed_kernel()
     #+end_src
  3. A partir de outro terminal rode o comando
     #+begin_src bash
     jupyter console --existing
     #+end_src
     - O =qtconsole= tamb√©m funciona
  4. Use =exit()= no terminal conectado para desligar o kernel
     - O gdb volta para o python interativo comum


* Outras dicas                                                             :noexport:
:PROPERTIES:
:CUSTOM_ID: conteudo-extra
:REVEAL_DATA_STATE: session-separation-slide
:END:
** Alguns outros comandos √∫teis
:PROPERTIES:
:CUSTOM_ID: outras-dicas
:END:
- =whatis <vari√°vel>= diz o tipo da vari√°vel
- =ptype <vari√°vel>= mostra uma descri√ß√£o do tipo da vari√°vel
- Use =skip= para n√£o entrar em uma fun√ß√£o
  - Ex: =foo(boring())= e voc√™ quer entrar em =foo=, mas n√£o em =boring=
    - Use =skip boring= e depois =step= para entrar em foo sem entrar em boring
- Frame filters: Veja no cppsim
  - Veja tb: http://jefftrull.github.io/c++/gdb/python/2018/04/24/improved-backtrace.html
- =info locals=
- =info args=
- Use the =pgrep= command in the shell to get the pid of a process and then =gdb -p <PID>= to attach to it

** Examplo de uso: Debugando Segmentation Fault                           :noexport:
:PROPERTIES:
:CUSTOM_ID: debugando-segmentation-fault
:REVEAL_DATA_STATE:
:END:
- Quando gerar um core file, use o comando abaixo

#+begin_src bash
$ gdb -c core.xxxx
#+end_src

#+begin_src gdb-script
print $pc
#+end_src

- =x= -> comando para examinar a mem√≥ria
- =x $= -> examina mem√≥ria do resultado do √∫ltimo comando
- =bt= -> Mostra o backtrace

Se isso n√£o resolver, rode o programa no gdb, d√™ =start= e rode o comando
=record=. Agora voc√™ pode usar o comando =reverse-stepi= para voltar um passo.

** Descobrindo quais fun√ß√µes do C++ podemos chamar no gdb                 :noexport:
:PROPERTIES:
:CUSTOM_ID: outras-dicas
:REVEAL_DATA_STATE:
:END:

- N√£o consegue chamar uma fun√ß√£o do seu c√≥digo quando parado no gdb?
  - Grepping the demangle symbols in the binary is a good way to know if the function
    you're trying to call is in teh binary


#+begin_src bash
nm -C your_binary | grep print_matrix
#+end_src

** Criando comandos customizados para o gdb
:PROPERTIES:
:CUSTOM_ID: criando-novos-comandos
:REVEAL_DATA_STATE:
:END:
https://interrupt.memfault.com/blog/automate-debugging-with-gdb-python-api

* Queremos um pouco mais                                                   :noexport:
:PROPERTIES:
:REVEAL_DATA_STATE: session-separation-slide
:END:
** akjshdas
:PROPERTIES:
:reveal_background: linear-gradient(to left, #910830, #521623)
:END:
** sdkjfhsdf

** dskjhfgsdf

* Perguntas?
:PROPERTIES:
:CUSTOM_ID: thats-all-folks
:REVEAL_DATA_STATE: the-end-slide
:END:
