#+TITLE: Um Pouco sobre GDB
#+AUTHOR: Darlan Cavalcante Moreira
#+DATE: Julho, 2022

#+OPTIONS: toc:1 num:nil timestamp:nil tags:nil
#+COLUMNS: %40ITEM %CUSTOM_ID %reveal_data_state %reveal_extra_attr

:MY-REVEAL-EXPORT-OPTIONS:
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_THEME: serif

#+REVEAL_MIN_SCALE:1
#+REVEAL_INIT_OPTIONS: margin: 0.0, width: 1777, height: 1000,
#+REVEAL_INIT_OPTIONS: slideNumber: "c/t", transition: 'slide', transitionSpeed: "fast", history: false, hash: true, respondToHashChanges: true
#+REVEAL_PLUGINS: (highlight notes zoom)
#+REVEAL_TITLE_SLIDE: <h1 class="title">%t</h1><h2>%s</h2></br></br></br><h3 class="author">%a</h3><h4 class="date">%d</h4>
#+REVEAL_TITLE_SLIDE_STATE: presentation-title-slide
#+HTML_HEAD_EXTRA: <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/a11y-dark.min.css">
#+HTML_HEAD_EXTRA: <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
#+REVEAL_EXTRA_CSS: css/code_blocks.css
#+REVEAL_EXTRA_CSS: css/kbd.css
#+MACRO: frag (eval (concat "@@html:<span class=\"fragment\">@@" $1 "@@html:</span>@@"))
#+MACRO: kbd (eval (concat "@@html:<kbd>@@" $1 "@@html:</kbd>@@"))


#+REVEAL_EXTRA_CSS: css/presentation.css
#+REVEAL_EXTRA_CSS: css/my_remark_main.css


:END:


* TODO Criar a class "dica" para um slide                                   :noexport:

Use
: :reveal_extra_attr: class="dica"
para atribuir a classe a um slide


* Bla bla                                                                  :noexport:
REVEAL_SPEED: fast
REVEAL_MARGIN: 0.05
REVEAL_INIT_OPTIONS: reveal_width:1188 reveal_height:840
# A4 dimensions: 210 297 -> Vou usar 4 x esses valores
REVEAL_INIT_OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:nil
REVEAL_INIT_OPTIONS: reveal_slide_number:c/t

* Primeiro o b√°sico
** Inicializando o GDB
:PROPERTIES:
:CUSTOM_ID:       inicializando-gdb
:END:

- Para executar o gdb basta usar o comando abaixo no terminal
  #+begin_src bash
  gdb <execut√°vel>
  #+end_src

- O terminal muda para o prompt do gdb, onde diversos comandos est√£o dispon√≠veis


#  +ATTR_HTML: :width 45% :align center
[[./images/gdb-screen.png]]

** TUI
:PROPERTIES:
:CUSTOM_ID: tui
:END:
- O GDB tamb√©m possui uma interface de usu√°rio em modo texto
- Use {{{kbd(Ctrl)}}}+{{{kbd(x)}}} {{{kbd(A)}}} para alternar entre a interface TUI e a interface normal
- Use {{{kbd(Ctrl)}}}+{{{kbd(x)}}} {{{kbd(2)}}} para dividir a tela
- Use {{{kbd(Ctrl)}}}+{{{kbd(x)}}} {{{kbd(1)}}} para voltar para uma √∫nica tela


#+ATTR_HTML: :class r-stretch
[[./images/gdb_tui.png]]

** Outros front-ends para GDB
:PROPERTIES:
:CUSTOM_ID: other-frontends
:END:
- Tamb√©m h√° v√°rios front-ends para o GDB
  - [[https://github.com/cs01/gdbgui/][gdbgui]]
  - [[https://github.com/epasveer/seer][seer]]
  - [[https://github.com/rohanrhu/gdb-frontend][gdb-frontend]]
  - etc.
- Provavelmente sua IDE ou editor de texto (no Linux) usa o GDB
  - [[https://www.jetbrains.com/clion/][CLion]]
  - [[https://www.kdevelop.org/][KDevelop]]
  - [[https://code.visualstudio.com/][VSCode]]
  - [[https://www.gnu.org/software/emacs/][Emacs]]

** Comandos principais do GDB
:PROPERTIES:
:CUSTOM_ID: comandos-principais
:END:

# box moody
#+ATTR_REVEAL: :frag (t)
- Muitos outros comandos est√£o dispon√≠veis
   # box happy
- Voc√™ n√£o precisa digitar o comando completo
    #+ATTR_REVEAL: :frag t
  - Uma ou duas letras s√£o suficientes
  - "=b=" para break, "=c=" para continue, etc


#+ATTR_REVEAL: :code_attribs data-line-numbers="3,8-10"
#+begin_src gdb-script
file
set args <command_line_parameters>
start
run, r
backtrace, bt
frame, f
next, n
step, s
finish, fin
up, u
down, d
break, b
rbreak, rb
continue, c
info <break/threads/locals/args/etc>
help, h
#+end_src

** Criando breakpoints
:PROPERTIES:
:CUSTOM_ID: criando-breakpoints
:END:

- √â poss√≠vel adicionar breakpoints com

  #+begin_src gdb-script
  b line_number
  b function_name
  b filename.cpp:line_number
  #+end_src

- Para templates o nome da fun√ß√£o deve incluir o tipo do template
- No caso da fun√ß√£o abaixo
  #+ATTR_REVEAL: :code_attribs data-line-numbers="3,8-10"
  #+begin_src c++ -n
  template <typename T>
  inline T doubleInput(const T& x) {
      return 2 * x;
  }
  #+end_src
  √© necess√°rio "=b doubleInput<int>=", ou "=b doubleInput<double>="
  - Note que ele vai parar apenas na inst√¢ncia espec√≠fica do template

- Caso use "=b filename.cpp:line_number=" em um template o gdb cria um breakpoint com
  m√∫ltiplas localiza√ß√µes (uma para cada inst√¢ncia do template)

** Criando breakpoints
:PROPERTIES:
:CUSTOM_ID: criando-breakpoints2
:END:

- Outra op√ß√£o √© usar o comando =rbreak= para criar um breakpoint passando uma express√£o regular

- Especialmente √∫til no caso de templates
- Com =rbreak doubleInput*= o gdb cria um breakpoint em todas as inst√¢ncias do template
#+begin_src c++
template <typename T>
inline T doubleInput(const T& x) {
    return 2 * x;
}
#+end_src

- Outra op√ß√£o interessante √© =rbreak filename.cpp:.*= para adicionar um breakpoint em
  todas as fun√ß√µes de um arquivo

* Algumas configura√ß√µes interessantes
** Evitando ver arquivos desinteressantes
:PROPERTIES:
:CUSTOM_ID: skip-files
:END:

- O comando =step= executa a pr√≥xima instru√ß√£o e vai entrar em fun√ß√µes se necess√°rio
- Muitas vezes ele entra em uma fun√ß√£o de uma biblioteca externa antes de entrar em uma fun√ß√£o do seu c√≥digo
- Para evitar que isso ocorra podemos dizer para o gdb pular arquivos
  desinteressantes (arquivos no namespace std, no namespace catch, do armadillo,
  etc)
- Mas muitas dessas fun√ß√µes s√£o d bibliotecas externas e normalmente n√£o
  queremos que o gdb entre nelas


#+begin_src gdb-script
skip -rfu Catch
skip -rfu _catch_sr
skip -rfu ^std::
skip -rfu ^arma::
#+end_src

** .gdbinit (global)
:PROPERTIES:
:CUSTOM_ID: gdbinit-global
:END:


- √â poss√≠vel configurar o gdb usando um arquivo =.gdbinit= na sua home
- M√≠nima configura√ß√£o √∫til

  #+begin_src gdb-script
  set history save on
  set print pretty on
  set pagination off
  set confirm off

  skip ...
  #+end_src

  # ![:box moody, Note]()
- O que voc√™ colocar no arquivo =.gdbinit= na sua home tamb√©m tem efeito quando o gdb √© usado com algum front-end
  # ![:box moody, Dica]()
- Voc√™ pode ter um arquivo =.gdbinit= em um projeto com diversas configura√ß√µes √∫teis para
  aquele projeto

** .gdbinit (local)
:PROPERTIES:
:CUSTOM_ID: gdbinit-local
:END:

- √â poss√≠vel tamb√©m ter um arquivo .gdbinit por projeto
  - Na verdade em cada pasta
- Ele √© carregado se o gdb for inicializado a partir daquela pasta (al√©m do
  arquivo .gdbinit na sua home)
- Ex: Coloque o conte√∫do abaixo em um arquivo chamado .gdbinit na mesma pasta
  contendo seu programa

#+begin_src gdb-script
file seu_executavel
start
b main.cpp:11
run
#+end_src

# ![:box angry, Nota]()
- Devido a quest√µes de seguran√ßa √© necessario adicionar a linha abaixo no arquivo .gdbinit na sua home


#+begin_src gdb-script
add-auto-load-safe-path /path_da_pasta_onde_esta_o_outro_gdb_init/
#+end_src

* Truques √∫teis
** Rodando comandos quando atingir algum breakpoint
:PROPERTIES:
:CUSTOM_ID: breakpoint-commands
:END:

- gdb permite setar comandos que devem ser rodados cada vez que um breakpoint espec√≠fico √© atingido
  - Qualquer comando do gdb pode ser executado dessa forma
  - At√© mesmo =run= para recome√ßar a execu√ß√£o do programa

- Ex: Inicialize o gdb normalmente

  #+begin_src bash
  gdb path_to_executable/executable_name
  #+end_src

- Voc√™ pode configurar os comandos com

#+begin_src gdb-script
commands <n√∫mero do breakpoint>
> algum comando
> outro comando
> end
#+end_src

** Exemplo
:PROPERTIES:
:CUSTOM_ID: breakpoint-commands-example
:reveal_extra_attr: data-auto-animate
:END:

- Encontrando um bug n√£o determin√≠stico

- O programa abaixo cria um array de 20 elementos e preenche o mesmo com valores aleat√≥rios
  - Na maior parte do tempo ele funciona, mas as vezes ele da crash


#+begin_src c++
#include <cstdlib>
#include <ctime>

int main() {
    srand(time(NULL));

    constexpr unsigned int arraySize = 20;
    int array[arraySize];

    for(unsigned int i = 0; i < arraySize; i++) {
        auto denominator = (rand() % 200);
        array[i]         = 1 / denominator;
    }

    return 0;
}
#+end_src

** Exemplo
:PROPERTIES:
:CUSTOM_ID: breakpoint-commands-example2
:reveal_extra_attr: data-auto-animate
:END:

# :reveal_extra_attr: data-transition="fade"


- Para encontrar o bug, primeiro adicionamos um breakpoint na √∫ltima instru√ß√£o do programa


#+begin_src gdb-script
start
b _exit
#+end_src

- Verificamos o n√∫mero do breakpoint com "=i b="
- Supondo que o n√∫mero do breakpoint em "=_exit=" √© 2, use "=gdb commands 2="
  - Agora escreva "=run=", pressione {{{kbd(Enter)}}}, e escreva "=end=" para finalizar
  - Rode o programa com o comando "=run="
  - Caso o programa termine sem atingir o bug ele chegar√° no breakpoint em
    "=_exit=" e ser√° automaticamente reinicializado pelo comando "=run=" at√© que
    eventualmente ele atinja o bug

** Exibindo uma express√£o sempre que parar
:PROPERTIES:
:CUSTOM_ID: display-variables
:END:

- Para imprimir uma vari√°vel ou express√£o sempre que parar em um breakpoint use
  #+begin_src gdb-script
  display expr
  #+end_src
  onde =expr= pode ser alguma express√£o ou vari√°vel
- Para ver o que foi configurado use
  #+begin_src gdb-script
  info display
  #+end_src
- Para deletar uma express√£o ou desabilit√°-la use
  #+begin_src gdb-script
  delete display <NUM>
  disable/enable display <NUM>
  #+end_src

** Vari√°veis de Conveni√™ncia
:PROPERTIES:
:CUSTOM_ID: convenience-variables
:reveal_extra_attr: data-auto-animate
:END:
- GDB permite setar "vari√°veis de conveni√™ncia"
  - Essas vari√°veis existem apenas no GDB e n√£o afetam o programa em execu√ß√£o
  - Voc√™ pode usar para guardar qualque tipo (valores, ponteiros, express√µes, etc)
- Vari√°veis de conveni√™ncia s√£o prefixadas com "=$="
  - Qualquer nome precedido de "=$=" √© v√°lido (exceto se for igual a algum registrador)
  # - Tamb√™m h√° "refer√™ncias de hist√≥rico", que s√£o n√∫meros precedidos de "=$="
- √â poss√≠vel criar uma vari√°vel de conveni√™ncia usando "=set="
  #+begin_src gdb-script
  set $foo = *object_ptr
  #+end_src
- Para ver o valor use
  #+begin_src gdb-script
  print $foo
  #+end_src
- Para mostrar todas as vari√°veis de conveni√™ncia use
  #+begin_src gdb-script
  show convenience
  #+end_src

# ![:box moody, Dica]




** Dica
:PROPERTIES:
:CUSTOM_ID: convenience-variables-hint
:END:

# :HTML_CONTAINER_CLASS: r-fit-text

Salve o ponteiro de um objeto em uma vari√°vel de conveni√™ncia

Voc√™ vai poder acessar o objeto mesmo que esteja em outra parte do programa

#+ATTR_REVEAL: :frag t :frag_idx
(desde que o objeto ainda exista)

** Arrays Artificiais
:PROPERTIES:
:CUSTOM_ID: view-arrays
:reveal_extra_attr: data-auto-animate
:END:
- √â poss√≠vel imprimir o conte√∫do de um array com

  #+begin_src gdb-script
  p *array@len
  #+end_src

- Funciona at√© mesmo para m√∫ltiplas dimens√µes (cuidado com a ordem)

  #+begin_src gdb-script
  p *array2d@num_cols@num_rows
  #+end_src
** Arrays Artificiais
:PROPERTIES:
:CUSTOM_ID: view-arrays-exemplo
:reveal_extra_attr: data-auto-animate
:END:


#+ATTR_REVEAL: :frag (t)
- As vari√°veis "=a=" e "=m=" podem ser impressas diretamente
- Mas "=aPtr=" e "=mPtr=" s√£o apenas ponteiros
  - precisamos usar "=@=" para passar o tamanho

#+html: <div class="columns">
#+html: <div class="column w-50">
#+CAPTION: Exemplo
#+ATTR_REVEAL: :code_attribs data-line-numbers="11"
#+begin_src c++
int main() {
    int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int* aPtr = a;

    int m[4][3] = {{1, 2, 3}, //
                   {4, 5, 6}, //
                   {7, 8, 9}, //
                   {10, 11, 12}};
    int* mPtr = &m[0][0];

    return 0;
}
#+end_src

#+html: </div>
#+html: <div class="column w-50">
#+ATTR_REVEAL: :frag t
[[./images/print_arrays.png]]
#+html: </div>
#+html: </div>

** Usando com tipos do Armadillo
:PROPERTIES:
:CUSTOM_ID: vendo-tipos-do-armadillo
:END:


- Os tipos do armadillo possuem um ponteiro chamado =mem= que aponta para a
  regi√£o de mem√≥ria onde os elementos s√£o armazenados
- Vara visualizar um vetor use o c√≥digo abaixo

#+begin_src gdb-script
p *myvec.mem@size
#+end_src

- Para matrizes use

#+begin_src gdb-script
p *mymat.mem@n_rows@n_cols
#+end_src


** Dica
:PROPERTIES:
:CUSTOM_ID: view-struct-arrays
:END:

- Para ver o valor de um campo em um array de estruturas, use uma vari√°vel de
  conveni√™ncia como contador
  #+begin_src gdb-script
  set $i = 0
  p mystruct_array[$i++]->some_field
  #+end_src
  #+ATTR_REVEAL: :frag t
  - Basta pressionar {{{kbd(Enter)}}} repetidamente para ver os pr√≥ximos elementos no array

#+ATTR_REVEAL: :frag (t)
- Tamb√©m √© poss√≠vel usar a vari√°vel de conveni√™ncia dentro de um loop para
  imprimir apenas um campo do array
  #+begin_src gdb-script
  set $i = 0
  while ($i<array_length)
      p mystruct_array[$i++]->some_field
  end
  #+end_src

* Tipos de breakpoints
** Setando breakpoint onde uma exce√ß√£o √© disparada
:PROPERTIES:
:CUSTOM_ID: break-in-exceptions
:END:

- Existem v√°rios tipos de breakpoint, como breakpoints que capturam eventos de `catch`


#+begin_src gdb-script
catch throw
run
#+end_src

- O problema √© que ele para em qualquer exce√ß√£o disparada
  - Dica: use "=catch throw=" como um commando que √© rodado quando algum outro
    breakpoint for atingido para capturar apenas exce√ß√µes disparadas depois dele

# ![:box moody, Nota](
- Veja outros eventos de catch em
  http://www.sourceware.org/gdb/current/onlinedocs/gdb.html#Set-Catchpoints

** Watchpoints
:PROPERTIES:
:CUSTOM_ID: watchpoints
:END:

- Tipo especial de breakpoint que para a execu√ß√£o do programa sempre que o valor de uma express√£o mudar
  - Ex: pare quando uma vari√°vel =x= for alterada

  #+begin_src gdb-script
  watch x
  #+end_src

- Tamb√©m √© poss√≠vel parar sempre que uma vari√°vel for lida com

  #+begin_src gdb-script
  rwatch x
  #+end_src

- Se quiser parar em ambos os casos use

  #+begin_src gdb-script
  awatch x
  #+end_src

  # ![:box happy, Dica]
Veja mais sobre breakpoints com =help breakpoints= no gdb

  # ![:box moody, Nota](
# - Se passar a op√ß√£o =-l= o gdb vai observar a regi√£o de mem√≥ria resultante da express√£o


* Python
:PROPERTIES:
:CUSTOM_ID: python
:END:
** gdb + Python = üíò
:PROPERTIES:
:CUSTOM_ID: gdb-com-python
:END:

#+ATTR_REVEAL: :frag (t)
- GDB possui um interpretador python integrado
- Use =python gdb.execute("some gdb command")= para executar comandos do gdb
- Use =python gdb.parse_and_eval("some_variable")= para passar para o python um valor do gdb
  #+ATTR_REVEAL: :frag t
  - Ex: suponha que existe uma vari√°vel "=a=" no seu programa. O comando =a =
    gdb.parse_and_eval('a')= vai criar um objeto no python representando essa
    vari√°vel
- Use =python help('gdb')= para ver documenta√ß√£o online

- Exemplos (rode esses comandos no terminal do gdb)

  #+begin_src gdb-script
  python bp = gdb.Breakpoint('main.cpp:13')
  python bp.enable=False
  python bps = gdb.breakpoints()
  python var_i = gdb.parse_and_eval('i')
  #+end_src

** Python Pretty Printers
:PROPERTIES:
:CUSTOM_ID: pretty-printers
:END:

- Possivelmente a aplica√ß√£o mais interessante de python com o gdb
- √â poss√≠vel criar e registrar pretty printers no GDB que o ensinam como
  imprimir um serto tipo de maneira mais amig√°vel
- Suponha que voc√™ tenha um tipo chamado =mysctruct= contento um campo =member=
  - Coloque o c√≥digo abaixo em um arquivo =.py=

#+begin_src python
class MyPrinter(object):
    def __init__(self, val):
        self.val = val
    def to_string(self):
        return (self.val['member'])

import gdb.printing
pp = gdb.printing.RegexpCollectionPrettyPrinter("mystruct")
pp.add_printer("mystruct", "^mystruct$", MyPrinter)
#+end_src

- Carregue o mesmo no gdb com =source filename.py=

# ![:box moody, Nota]()
- Coloque `set print pretty on` no arquivo `.gdbinit` na sua home

** Python Pretty Printers
:PROPERTIES:
:CUSTOM_ID: pretty-printers2
:END:

- O GDB j√° vem com pretty printers para os tipos da STL
- Para o armadillo, alguns pretty printers est√£o dispon√≠veis em <https://github.com/darcamo/gdb_armadillo_helpers>
- Ap√≥s clonar o reposit√≥rio, adicione as linhas abaixo no seu .gdbinit

#+begin_src gdb-script
source /path_onde_clonou/gdb_armadillo_helpers/gdb_helpers/gdb_armadillo_printers.py
source /path_onde_clonou/gdb_armadillo_helpers/gdb_helpers/gdb_std_complex_printer.py
#+end_src

** XMethods
:PROPERTIES:
:CUSTOM_ID: xmethods
:END:
- Outra aplica√ß√£o de Python+GDB
- Xmethods s√£o m√©todos adicionais ou substitutos para m√©todos de uma classe em
  C++
  - √ötil para casos quando os m√©todos definidos no C++ n√£o estejam dispon√≠veis
    (inline, optimized-out, etc)
- Para implementar um xmethod √© necess√°rio criar um =matcher= e um =worker=
  - Mais de um =worker= pode ser implementado para um mesmo xmethod, cada um
    correspondendo a um overload diferente


- Para o armadillo, alguns pretty printers est√£o dispon√≠veis em <https://github.com/darcamo/gdb_armadillo_helpers>
- Ap√≥s clonar o reposit√≥rio, adicione as linhas abaixo no seu .gdbinit

#+begin_src gdb-script
source /path_onde_clonou/gdb_armadillo_helpers/gdb_helpers/gdb_armadillo_xmethods.py
#+end_src

** Python Interativo
:PROPERTIES:
:CUSTOM_ID: python-interativo
:END:

- O comando =pi= (ou =python-interactive=) do gdb roda o python de maneira
  iterativa
  - √ötil para testes e para explorar a API
- Adicione a linha abaixo no seu .gdbinit ap√≥s clonar o reposit√≥rio
  =gdb_armadillo_helpers= para ter a fun√ß√£o =get_arrat= dispon√≠vel no python do gdb


#+begin_src gdb-script
source /path_onde_clonou/gdb_armadillo_helpers/gdb_helpers/gdb_armadillo_to_numpy.py
#+end_src

- Agora rode o python iterativo com o comando =pi=
- Supondo que voc√™ possui um =arma::cx_mat= de nome =m= voc√™ pode criar um numpy
  array a partir dele com

#+begin_src python
>>> m_numpy = get_array(gdb.parse_and_eval('m'))
#+end_src

** Exemplo √∫til: Computar posi√ß√µes dos elementos de uma URA
:PROPERTIES:
:CUSTOM_ID: exemplo1
:END:

  - Crie um arquivo =.gdbinit= na pasta contento o execut√°vel (chamado de =tests=)


#+begin_src gdb-script
  file tests
  set args "[Antenna]"
  start
  # Linha 311 √© logo ap√≥s a vari√°vel 'positions' ser setada
  b test_URA.cpp:311
  commands 2
    source plot_positions.py
  end
  run
#+end_src


  - Na mesma pasta crie o arquivo =plot_positions.py= com o conte√∫do abaixo


#+begin_src python
  from matplotlib import pyplot as plt
  p = get_array(gdb.parse_and_eval("positions")) # positions √© a vari√°vel no C++
  plt.plot(p[1], p[2], "*")
  for i in range(p.shape[1]):
      plt.text(p[1,i], p[2,i], i)
  plt.show()
#+end_src

** Exemplo √∫til: Computar posi√ß√µes dos elementos de uma URA
:PROPERTIES:
:CUSTOM_ID: exemplo2
:END:
- Agora basta rodar =gdb= e o programa vai parar na linha 311 e plotar as
  posi√ß√µes dos elementos de antenna


[[gdb_matplotlib.png]]

** IPython Interativo
:PROPERTIES:
:CUSTOM_ID: ipython-interativo
:END:
- O python interativo do gdb funciona bem, mas n√£o chega perto de um IPython
- Iniciar o IPython a partir do gdb n√£o funciona (tab completion n√£o funciona
  al√©m de outros problemas
- **Workaround:** Inicializar um kernel embeded e conectar a partir de outro terminal
  1. Inicialize o python interativo com =pi=
  2. No python interativo rode o comando
     #+begin_src python
     import IPython; IPython.embed_kernel()
     #+end_src
  3. A partir de outro terminal rode o comando
     #+begin_src bash
     jupyter console --existing
     #+end_src
     - O =qtconsole= tamb√©m funciona
  4. Use =exit()= no terminal conectado para desligar o kernel
     - O gdb volta para o python interativo comum

** Outras Dicas
:PROPERTIES:
:CUSTOM_ID: outras-dicas
:END:
- =whatis <vari√°vel>= diz o tipo da vari√°vel
- =ptype <vari√°vel>= mostra uma descri√ß√£o do tipo da vari√°vel
- Use =skip= para n√£o entrar em uma fun√ß√£o
  - Ex: =foo(boring())= e voc√™ quer entrar em =foo=, mas n√£o em =boring=
    - Use =skip boring= e depois =step= para entrar em foo sem entrar em boring
- Frame filters: Veja no cppsim
  - Veja tb: http://jefftrull.github.io/c++/gdb/python/2018/04/24/improved-backtrace.html
- =info locals=
- =info args=
- Use the =pgrep= command in the shell to get the pid of a process and then =gdb -p <PID>= to attach to it

* Examplo de uso: Debugando Segmentation Fault
:PROPERTIES:
:CUSTOM_ID: debugando-segmentation-fault
:END:
- Quando gerar um core file, use o comando abaixo

#+begin_src bash
$ gdb -c core.xxxx
#+end_src

#+begin_src gdb-script
print $pc
#+end_src

- =x= -> comando para examinar a mem√≥ria
- =x $= -> examina mem√≥ria do resultado do √∫ltimo comando
- =bt= -> Mostra o backtrace

Se isso n√£o resolver, rode o programa no gdb, d√™ =start= e rode o comando
=record=. Agora voc√™ pode usar o comando =reverse-stepi= para voltar um passo.

* Outras dicas
:PROPERTIES:
:CUSTOM_ID: outras-dicas
:END:

- N√£o consegue chamar uma fun√ß√£o do seu c√≥digo quando parado no gdb?
  - Grepping the demangle symbols in the binary is a good way to know if the function
    you're trying to call is in teh binary


#+begin_src bash
nm -C your_binary | grep print_matrix
#+end_src

* Criando comandos customizados para o gdb
:PROPERTIES:
:CUSTOM_ID: criando-novos-comandos
:END:
https://interrupt.memfault.com/blog/automate-debugging-with-gdb-python-api

* Make gdb's python use a virtual environment
https://interrupt.memfault.com/blog/using-pypi-packages-with-GDB

* Queremos um pouco mais
** akjshdas
:PROPERTIES:
:reveal_background: linear-gradient(to left, #910830, #521623)
:END:
** sdkjfhsdf

** dskjhfgsdf
